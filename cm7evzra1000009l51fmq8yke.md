---
title: "상품 조회 성능 개선 이야기"
datePublished: Fri Feb 21 2025 15:00:00 GMT+0000 (Coordinated Universal Time)
cuid: cm7evzra1000009l51fmq8yke
slug: product-api-optimization
tags: developer

---

최근에, 상품 상세 API의 문제를 빠르게 개선할 수 있었는데요. 어떻게 빠르게 개선할 수 있었는지에 대해 작성해보려고합니다.

## 이슈 발견과 해결 과정

슬랙에서 상품 상세 API의 성능 저하 이슈가 제기되었습니다. 제가 이전에 이 API를 레거시 서비스에서 신규 서비스로 전환하는 작업을 담당했었기 때문에, 문제의 원인을 빠르게 파악할 수 있었습니다.

원인은 판매량을 구하기 위해 사용하던 쿼리에 있는 SUM 함수였습니다. 데이터가 많은 경우 이런 집계 함수는 성능 확보가 어렵습니다. 그래서 이 상품 상세 API에서 판매량을 구하는 쿼리를 제거하고, 클라이언트에서 별도의 판매량 API를 호출하는 방향으로 쉽고 빠르게 개선할 수 있었습니다.

배포는 14일에 이루어졌고, 성능 개선이 이루어진 걸 확인할 수 있습니다.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1740146634939/4bdc3c3c-1dc8-48c1-add7-3392c39eaf02.png align="center")

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1740146653359/e1b77441-4299-444e-96f7-cfb21088dbc8.png align="center")

결과만 놓고 보면, 단순히 API만 나눈 간단한 작업 같지만, 이렇게 간단하게 처리할 수 있었던 이유는 점진적으로 상품 API의 문제를 개선했기 때문입니다.

## 배치 처리를 통한 개선

처음에는 모든 상품 관련 API에서 판매량을 함께 조회하고 있었습니다. 당연하게도 앞서 말한 상품 상세 API와 마찬가지로, 판매량을 구하는 쿼리에서 지속적인인 성능 이슈가 발생했습니다.

그래서 이 문제를 해결하기 위해 판매량 집계를 배치 작업으로 분리했습니다. 주기적으로 판매량을 집계한 후, 그 결과를 별도 테이블에 저장하여 조회하도록 했습니다.

대부분의 상품은 이러한 방식으로 개선할 수 있었지만, 일부 상품 유형의 경우 개발 리소스나 운영 비용 대비 효과가 크지 않아 배치 작업이나 이벤트 스트리밍 처리가 적합하지 않았습니다.

## 판매량 조회 API 분리

그래서 이러한 특수한 상품들을 위해 별도의 판매량 조회 API를 만들었습니다. 기존 상품 정보를 조회하는 쿼리에서 판매량을 구하는 부분을 제거하고, 판매량 조회는 별도 API를 통해 처리하도록 분리했습니다. 이렇게 함으로써 사용자들은 판매량을 제외한 상품 정보를 먼저 확인할 수 있게 되었습니다.

그러나 새로운 문제가 발생했습니다. 분리한 API에 캐시를 적용했지만, Cache Stampede 현상이 발생했습니다. 이는 캐시가 만료되거나 존재하지 않는 상태에서 동시에 많은 요청이 들어와 모든 요청이 DB에 직접 접근하게 되는 현상입니다. 이로 인해 순간적으로 DB에 큰 부하가 발생하는 문제가 있었습니다.

이 문제를 해결하기 위해 `@Cacheable` 어노테이션의 sync 옵션을 다음과 같이 true로 설정했습니다:

```java
@Cacheable(sync = true)
public Response xxx(final Request request) {
    ...
}
```

이 설정의 동작 방식은 다음과 같습니다:

1. 캐시 키별로 락(lock)을 사용하여 동시성을 제어합니다
    
2. 같은 키에 대한 여러 요청이 동시에 들어올 경우:
    
    * 첫 번째 스레드만 실제로 DB를 조회하여 판매량을 계산
        
    * 다른 스레드들은 첫 번째 스레드의 작업이 완료될 때까지 대기
        
    * 작업이 완료되면 그 결과를 캐시에 저장하고, 대기하던 모든 스레드는 캐시된 동일한 결과값을 사용
        

이를 통해 DB 부하를 크게 줄일 수 있었습니다. 예를 들어, 캐시가 없는 상태에서 동일한 상품에 대해 100개의 요청이 동시에 들어와도 실제 DB 조회는 1번만 발생하게 됩니다.

## 캐시 전략 개선

이번엔 sync 옵션으로 인한 새로운 문제가 발생했습니다. DB의 부하는 줄일 수 있었지만, 캐시가 만료되는 시점에 들어온 요청들은 락으로 인해 대기 상태에 빠지게 되어 애플리케이션의 응답 시간이 늘어나는 현상이 발생했습니다. 특히 판매량 계산에 시간이 오래 걸리는 경우, 사용자 경험에 좋지 않은 영향을 미쳤습니다.

이를 해결하기 위해 SWR(Stale-While-Revalidate) 캐싱 전략을 도입했습니다. 이 방식은 캐시가 만료되어도 일단 기존 데이터를 반환하고, 백그라운드에서 새로운 데이터를 가져와 캐시를 갱신합니다.

```java
@StaleWhileRevalidateCacheable // 커스텀 어노테이션
public Response xxx(final Request request) {
    ...
}
```

이렇게 함으로써 다음과 같은 이점을 얻을 수 있었습니다:

* 락 대기 시간 제거: 기존 방식에서는 캐시가 만료될 때 동시 요청이 발생하면 락으로 인해 대기 시간이 길어질 수 있었지만, SWR 방식에서는 즉시 캐시된 데이터를 반환하기 때문에 대기 시간이 사라짐.
    
* 더 빠른 응답 제공: 사용자는 항상 캐시된 데이터를 기반으로 즉각적인 응답을 받을 수 있음.
    
* DB 부하 완화 유지: 백그라운드에서 갱신이 이루어지므로 기존 방식처럼 캐시 만료 시 DB 부하가 폭증하는 현상을 방지.
    

## 마무리

이번 개선 작업은 단순히 API를 분리하는 사소한 변경처럼 보일 수 있지만, 사실 그동안 꾸준히 상품 API의 성능을 개선해 온 과정이 있었기 때문에 가능했던 일이었습니다.

점진적으로 개선해 나가다 보면, 어느 순간 작은 변경만으로도 예상보다 큰 변화를 만들 수 있는 순간이 찾아옵니다. 처음부터 완벽한 해결책을 고민하기보다는, 시스템의 병목을 주기적으로 점검하고 현실적인 범위에서 개선해 나가는 접근이 결국 더 안정적이고 효과적인 결과로 이어진다는 점을 다시 한번 확인할 수 있었습니다.